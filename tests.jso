

autowatch = 1;


var Util = new Object();
// Also see:
// http://www.optimalworks.net/blog/2007/web-development/javascript/array-detection
Array.Is = function(array) {
  return (array !== null) &&
    (typeof(array) == 'object') &&
    ((array.prototype === Array.prototype) ||
     (array.constructor &&
      !array.nodeType &&
      !array.item &&
      array.length !== undefined));
};
// Compare two items that might be lists.  Crave Python.
Util.Compare = function(item1, item2) {
  var poster = function(_) {};
  if (Testing.verbose_compare) {
    poster = function(_) {
      post(['Util.Compare:'].concat(arrayfromargs(arguments)), '\n');
    };
  }
  if ((!item1) != (!item2)) {
    poster("one item was empty, the other wasn't", item1, item2);
    return false;
  }
  var t1 = typeof(item1);
  var t2 = typeof(item2);
  if (t1 != t2) {
    poster('different types', t1, t2);
    return false;
  }
  if (t1 != 'object') {
    if (item1 == item2)
      return true;
    poster('not objects, not equal: ', item1, ' != ', item2);
    return false;
  }
  var a1 = Array.Is(item1);
  var a2 = Array.Is(item2);
  if (a1 != a2) {
    poster("only one item was an array", item1, item2);
    return false;
  }
  function subset(item1, item2) {
    for (var i in item1) {
      if (!(i in item2)) {
        poster('index', i, 'missing in item');
        return false;
      }
      if (!Util.Compare(item1[i], item2[i])) {
        poster('index', i, ':', Print(item1[i]), '!=', Print(item2[i]));
        return false;
      }
    }
    return true;
  };

  if (!a1)
    return subset(item1, item2) && subset(item2, item1);

  if (item1.length != item2.length) {
    poster('lengths differ', item1.length, item2.length);
    for (var i = 0; i < item1.length; ++i)
      poster('item', i, Print(item1[i]));
    return false;
  }

  for (var i = 0; i < item1.length; ++i) {
    if (!Util.Compare(item1[i], item2[i]))
      return false;
  }
  return true;
};
var MAX_DEPTH = 10;
function Print(item, depth) {
  depth = depth || 0;
  if (depth > MAX_DEPTH)
    return 'MAX_DEPTH';
  if (item == null)
    return 'null';
  if (item == 'undefined')
    return 'undefined';
  var t = typeof(item);
  if (t == 'string')
    return '"' + item + '"';
  if (t == 'function')
    return (item.name || 'unknown') + '()';
  if (t != 'object')
    return item + '';
  var is_array = Array.Is(item);
  var result = [is_array ? '[' : '{'];
  for (var index in item) {
    if (result.length > 1)
      result[result.length - 1] += ', ';
    var value = Print(item[index], depth + 1);
    result.push(is_array ? value : '"' + index + '": ' + value);
  }
  result.push(is_array ? ']' : '}');
  return result.join('');
};
var Testing = new function() {
  var test_count;
  var fail_count;
  var name_map;
  var functions = [];
  function Reset() {
    Testing.results = [];
    Testing.verbose = false; // true
    Testing.verbose_compare = true;
    test_count = 0;
    fail_count = 0;
    name_map = {};
  };
  function Start(name) {
    var count = (name in name_map) ? (name_map[name] + 1) : 1;
    name_map[name] = count;
    if (Testing.verbose)
      post('Test:', name, count, '\n');
    ++test_count;
  };
  function Fail(name, results, expected) {
    ++fail_count;
    post('FAIL:', name, name_map[name], '\n');
    post('Actual result:', Print(results).slice(0, 255), '\n');
    post('Expect result:', Print(expected).slice(0, 255), '\n');
  };
  this.ExpectEqual = function(name, results, expected) {
    Start(name);
    return Util.Compare(results, expected) || Fail(name, results, expected);
  };
  this.TestFunction = function(f) {
    functions.push(f);
  };
  this.ExpectFunction = function(name, f, target, data, expected, side_effect) {
    Start(name);
    if (side_effect)
      Testing.results = [];
    var results;
    try {
      results = f.apply(target, data);
      if (side_effect)
        results = Testing.results;
      if (Util.Compare(results, expected))
        return true;
    } catch (e) {
      results = e.name + ': ' + e.message + ' at line ' + e.lineNumber;
    }
    return Fail(name, results, expected);
  };
  this.Run = function() {
    post('--- start\n');
    Reset();
    for (var i = 0; i < functions.length; ++i)
      functions[i]();
    if (fail_count)
      post(fail_count, 'tests in', test_count, 'FAILED.');
    else
      post('\nAll', test_count, 'tests succeeded.');
    post('\n--- end\n');
    post('---\n');
  };
}();
// Unit tests start here.
// Concatinate two arguments or argument lists, only returning a new list if
// both lists are non-empty.
Array.Concat = function(x, y) {
  if (!(x && x.length))
    return y;
  if (!(y && y.length))
    return x;
  if (!x.concat)
    x = arrayfromargs(x);
  if (!y.concat)
    y = arrayfromargs(y);
  return x.concat(y);
};
Testing.TestFunction(function() {
  function getArgs(_) { return arguments; }
  Testing.ExpectFunction('Array.concat', Array.Concat, this,
                         [getArgs(), getArgs()], getArgs());
  Testing.ExpectFunction('Array.concat', Array.Concat, this,
                         [getArgs(1), getArgs()], getArgs(1));
  Testing.ExpectFunction('Array.concat', Array.Concat, this,
                         [getArgs(1, 2), getArgs()], getArgs(1, 2));
  Testing.ExpectFunction('Array.concat', Array.Concat, this,
                         [getArgs(1), getArgs(2)], [1, 2]);
});
// Array.ForEach iterates over a collection with a 2-argument function f(name,
// item).  If the collection is an array, ForEach calls f(item, item) for each
// item in the collection:  otherwise, ForEach calls f(index, collection[index])
// for each index in the associative array.
//
// This is very useful for reading data or function arguments where you usually
// want the name and the thing itself to be the same but sometimes want to
// have the name and thing iself be different.
Array.ForEach = function(collection, f, reverse) {
  var is_array = Array.Is(collection);
  for (var name in collection) {
    var value = collection[name];
    if (is_array)
      f(value, value);
    else if (reverse)
      f(value, name);
    else
      f(name, value);
  }
};
Testing.TestFunction(function() {
  function f(name, value) {
    Testing.results.push([name, value]);
  };
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [[1, 2, 3], f],
                         [[1, 1], [2, 2], [3, 3]], true);
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [{1:'a', 2:'b'}, f, true],
                         [['a', '1'], ['b', '2']], true);
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [{1:'a', 2:'b'}, f],
                         [['1', 'a'], ['2', 'b']], true);
});
Testing.TestFunction(function() {
  Testing.ExpectFunction('array', Array.Is, this, [[1]], true);
  Testing.ExpectFunction('array', Array.Is, this, [[]], true);
  Testing.ExpectFunction('array', Array.Is, this, [[1, 2]], true);
  Testing.ExpectFunction('array', Array.Is, this, [{}], false);
  Testing.ExpectFunction('array', Array.Is, this, [{1:1}], false);
  Testing.ExpectFunction('array', Array.Is, this, [new Object()], false);
  function f(name, value) {
    Testing.results.push([name, value]);
  };
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [[1, 2, 3], f],
                         [[1, 1], [2, 2], [3, 3]], true);
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [{1:'a', 2:'b'}, f, true],
                         [['a', '1'], ['b', '2']], true);
  Testing.ExpectFunction('array',
                         Array.ForEach, this, [{1:'a', 2:'b'}, f],
                         [['1', 'a'], ['2', 'b']], true);
});
function test() {
  Testing.Run();
};
post('recompiled test.js');
