inlets = 1;
autowatch = 1;








var Max = new Object();
Max.patcher = this.patcher;






var Util = {};

Util.ArrayToString = function(s) {
  return Util.IsString(s) ? s : s[0];
};

Util.RemoveQuotes = function(s) {
  var begin = 0, end = s.length;
  if (end && s[begin] == '"')
    ++begin;
  if (end > begin && s[end - 1] == '"')
    --end;
  return s.substring(begin, end);
};

Util.LiveStringToString = function(s) {
  return Util.RemoveQuotes(Util.ArrayToString(s));
};

Util.endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

Util.addSuffix = function(str, suffix) {
    return Util.endsWith(str, suffix) ? str : str + suffix;
};

// Max.SetOutlets sets the names and thus the number of outlets for your Max js
// box.
//
// A sample call looks like:
//
//    Max.SetOutlets('midi',
//                   ['synth', 'Messages to the synthesis subpatcher.'],
//                   ['finished', 'Outlets a bang when the song is finished.']);
//
// or more generally, like this:
//
//    Max.SetOutlets(out1, out2, ...);
//
// Each name argument can either be a string, or a list of two strings.  For
// each argument, the name of the corresponding outlet is the first string, and
// the help text is the second string, if there is one, or else the name of the
// outlet.
//
//    You should only call this function once, and you have to call it during
// the "top-level phase" when the Javascript is first being executed and before
// the box is actually created - if you try to call this later, nothing will
// fail, but you won't get the right number of outlets from the js box.
//
// Once you've called
// If you start with:
//
//   Max.SetOutlets('foo', 'bar', 'baz');
//
// then the following code blocks have identical meaning, and all send the
// message ['hello', 'world'] out the first outlet, named foo, and the message
// ['hello', 'there!'] and ['goodbye!' out the second Max outlet, named bar:
//
//   {
//     Max.Out('foo', 'hello', 'world');
//     Max.Out('bar', 'hello', 'there!');
//     Max.Out('bar', 'goodbye!');
//   }
//
//   {
//     Max.Out.foo('hello', 'world');
//     Max.Out.bar('hello', 'there!');
//     Max.Out.bar('goodbye!');
//   }
//
//   {
//     Max.ListOut(['foo', 'hello', 'world'],
//                 ['bar', 'hello', 'there!'],
//                 ['bar', 'goodbye!']);
//   }
//
//   {
//     Max.ListOut.foo(['hello', 'world']);
//     Max.ListOut.bar(['hello', 'there!'], ['goodbye!']);
//   }
//
//   {
//     var func = Max.Outer(['foo', 'hello', 'world'],
//                          ['bar', 'hello', 'there!'],
//                          ['bar', 'goodbye!']);
//     func();
//   }
//
//   {
//     var func1 = Max.Outer.foo(['hello', 'world']);
//     var func2 = Max.Outer.bar(['hello', 'there!'], ['goodbye!']);
//
//     func1();
//     func2();
//   }
//

Max._outlets = {};

// Outlet to a named outlet.  You can still use the numbered outlets, too.
// You can override this in tests if you want to capture the MIDI output.
//
Max.Outlet = function(outletNumber, data) {
  if (Max._outlets && outletNumber in Max._outlets)
    outletNumber = Max._outlets[outletNumber];
  outlet(outletNumber || 0, data);
};

Max.Out = function(out, _) {
  Max.Outlet(out, arrayfromargs(arguments).slice(1));
};

Max.ListOut = function(args) {
  for (var i = 0; i < args.length; ++i)
    Max.Outlet(args[i][0], args[i].slice(1));
};

Max.Outer = function(_) {
  var args = arguments;
  return function() {
    for (var i = 0; i < arguments.length; ++i)
      Max.Outlet(arguments[i][0], arguments[i].slice(1));
  };
};

Max.SetOutlets = function(_) {
  outlets = arguments.length;
  Max._outlets = {};
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i], help = name;
      if (!isString(name)) {
      help = name[1] || name;
      name = name[0];
    }

    Max._outlets[name] = i;
    setoutletassist(i, help);
    var f = Max.OutletFunction(i);
    f.Partial = function(_) {
      var args = arrayfromargs(arguments);
      return function(_) {
        var a = args.concat(arrayfromargs(arguments));
        return f.apply(this, a);
      };
    };
    Max.Out[name] = f;

    Max.ListOut[name] = Max.OutletListFunction(i);
    Max.Outer[name] = Max.OutletFunctionMaker(i);
  }
};

//
// Implementation details below here!
//

// Returns a function that sends its arguments as a message to a given outlet.
Max.OutletFunction = function(out) {
  return function(_) {
    outlet(out, arrayfromargs(arguments));
  };
};

// Returns a function that sends its arguments as separate messages to a given
// outlet.
Max.OutletListFunction = function(out) {
  return function(_) {
    for (var i = 0; i < arguments.length; ++i)
      outlet(out, arguments[i]);
  };
};

// Returns a function that sends its arguments as separate messages to a given
// outlet.
Max.OutletFunctionMaker = function(out) {
  return function(messages) {
    return function() {
      for (var i = 0; i < messages.length; ++i)
        outlet(out, messages[i]);
    }
  };
};




var MAX_DEPTH = 10;

function Print(item, depth) {
  depth = depth || 0;
  if (depth > MAX_DEPTH)
    return 'MAX_DEPTH';

  if (item == null)
    return 'null';

  if (item == 'undefined')
    return 'undefined';

  var t = typeof(item);
  if (t == 'string')
    return '"' + item + '"';

  if (t == 'function')
    return (item.name || 'unknown') + '()';

  if (t != 'object')
    return item + '';

  var is_array = item instanceof Array;
  var result = [is_array ? '[' : '{'];

  for (var index in item) {
    if (result.length > 1)
      result[result.length - 1] += ', ';
    var value = Print(item[index], depth + 1);
    result.push(is_array ? value : '"' + index + '": ' + value);
  }
  result.push(is_array ? ']' : '}');
  return result.join('');
}

function PrintJoin(_) {
  var res = [];
  for (var i = 0; i < arguments.length; ++i)
    res.push(Print(arguments[i]));
  return res.join(' ');
}

// This is a VERY useful function - it converts Javascript objects into a
// human-readable form, prints them on one line and then adds a trailing \n.
function Postln(_) {
  for (var i = 0; i < arguments.length; ++i)
    post(Print(arguments[i]));

  post('\n');
}

function print(_) {
    if (arguments.length) {
        for (var i = 0; i < arguments.length; ++i)
            post(arguments[i]);
    } else {
        post(' ');
    }
    post();
}

function printable(x) {
    if (x === null)
        return '<null>';

    if (x === undefined)
        return '<undefined>';

    if (typeof(x) == 'object')
        return JSON.stringify(x);

    return String(x);
}

function maxLog(_) {
    for (var i = 0; i < arguments.length; i++)
        post(printable(arguments[i]));
}

var Logging = {};

Logging.setLogging = function(on) {
  Logging.Log = on ? Postln : function() {};
};

Logging.setLogging(false);






Dict = {};

Dict.Setter = function(dict) {
    return function(key, value) {
        dict[key] = value;
    };
};

Dict.GetOrAddDefault = function(table, key, value) {
  if (key in table)
    value = table[key];
  else
    table[key] = value;

  return value;
};

Dict.Copy = function(dict) {
  return Dict.CopyTo(dict, {});
};

Dict.CopyTo = function(from, to) {
  for (var name in from)
    to[name] = from[name];
  return to;
};

Dict.values = function(dict) {
    var results = [];
    for (var i in dict)
        results.push(dict[i]);
    return results;
};

Dict.GetCommandFromMap = function(map, input) {
  if (!input || !input.length) {
    print('ERROR: Empty input', Print(input));
    return;
  }

  for (var i = 0; ; ++i) {
    if (!map) {
      print('ERROR: Didn\'t understand input', Print(input));
      return;
    }

      if (isString(map))
      return {command: map, data: input.slice(i + 1)};

    if (i >= input.length) {
      print('ERROR: Ran out during input', Print(input));
      return;
    }

    map = map[input[i]] || map['*'];
  }
};

Dict.remap = function(map, assignments) {
    var result = {};
    for (var a in assignments)
        result[map[a]] = assignments[a];
    return result;
};

Dict.update = function(to, from) {
    for (var i in from)
        to[i] = from[i];
};

Dict.offset = function(offset, dict) {
    var result = {};
    for (var i in dict)
        result[i] = dict[i] + offset;
    return result;
};

Dict.union = function(_) {
    var result = {};
    for (var i in arguments)
        Dict.update(result, arguments[i]);
    return result;
};

Dict.invert = function(array) {
    var result = {};
    forEach(array, function(value, index) {
        if (value in result)
            throw 'Dict.invert: Duplicate value ' + v;
        result[value] = index;
    });
    return result;
};

Dict.oneach = function(dict, f) {
    for (var k in dict)
        dict[k] = f(dict[k], k);
};


Dict.forEach = function(dict, f) {
    for (var k in dict)
        f(dict[k], k);
};

/** Get a value from a dictionary, or throw an exception. */
Dict.get = function(dict, key, errorName) {
    var result = dict[key];
    if (result !== undefined)
        return result;
    throw 'Couldn\'t find key ' + key + ' in dictionary ' + (errorName || '');
};

/** Return a function that gets a value from a dictionary, or throws an
    exception. */
Dict.getter = function(dict, errorName) {
    return function(key) {
        return Dict.get(dict, key, errorName);
    };
};

Dict.keyGetter = function(key, errorName) {
    return function(dict) {
        return Dict.get(dict, key, errorName || key);
    };
};

Dict.concat = function(args) {
    return args.reduce(function(p, c) { return p + c; }, []);
};

Dict.sequence = function(functions) {
    return function() {
        functions.forEach(function(f) { f(); });
    };
};

/** Flatten an array of arrays and promote scalars to arrays.
    The result is a flat list of non-lists. */
Dict.flatten = function(args) {
    if (!(args instanceof Array))
        return [args];
    var result = [];
    args.forEach(function(a) {
        result = result.concat(Dict.flatten(a));
    });
    return result;
};

Dict.duplicateValue = function(n, value) {
    var result = [];
    for (var i = 0; i < n; ++i)
        result.push(value);
    return result;
};

/** Imperfect function to iterate over different types.  If we start extending
 the prototypes of basic classes, this won't work.  */
function forEach(coll, f) {
    if (coll instanceof Array)
        coll.forEach(f);
    else
        Dict.forEach(coll, f);
}

var forEachObj = Dict.forEach;

function forEachSorted(coll, f) {
    var keys = Object.keys(coll);
    keys.sort();
    keys.forEach(function(key) {
        f(coll[key], key);
    });
};

function applyEachArray(coll, f) {
    var result = [];
    coll.forEach(function() {
        result.push(f.apply(this, arguments));
    });
    return result;
}

function applyEachObj(coll, f) {
    var result = {};
    for (var i in coll)
        result[i] = f(coll[i], i, coll);
    return result;
}

function appendEachObj(coll, f) {
    var result = [];
    for (var i in coll)
        result.push(f(coll[i], i, coll));
    return result;
}

function applyEach(coll, f) {
    var iterator = (coll instanceof Array) ? applyEachArray : applyEachObj;
    return iterator(coll, f);
}

function sequenceEach(functions) {
    return function(_) {
        var args = arguments;
        forEach(functions, function(func) {
            func.apply(this, args);
        });
    };
};

// TODO: move this somewhere better!
function isString(s) {
    return (s.constructor === String);
}

Max.SetOutlets(
    ['router', 'Commands to router object.'],
    ['selection', 'A two-element list with the in/out selection names.']
);

function Matrix(config) {
    this.setConfig(config || this.default_config);
}

Matrix.prototype.setConfig = function(config) {
    for (var name in config)
        this[name] = config[name];

    this.columns = (this.column_names && this.column_names.length)
        || this.columns;
    this.rows = (this.row_names && this.row_names.length)
        || this.rows;
    this.colors = [
        this.color.disabled,
        this.color.enabled,
        this.color.clicked_for_enable,
        this.color.clicked_for_disable,
        this.color.will_be_disabled];

    this.matrix = new Array(this.columns);
    this.selection = undefined;

    for (var c = 0; c < this.columns; ++c)
        this.matrix[c] = new Array(this.rows);

    this.resize();
};

Matrix.prototype.resize = function() {
    /** Reminder: width is measured in columns, height in rows.

        In the jsui world, all canvases are normalized as follows:
        aspect = width / height

        and laid out like this:

          top left hand corner:     [-aspect, 1]
          top right hand corner:    [aspect,  1]
          bottom left hand corner:  [-aspect, -1]
          bottom right hand corner: [aspect,  -1]

        so coordinates increase from left to right, and from bottom to top.

        Concrete example: a 5x4 matrix.  Natural aspect ratio is 1.25.  If the
        actual aspect ratio is less than 1.25, then we fill the columns and have
        space below the rows.  If it's greater than 1.25, we fill the rows and
        have space to the right of the columns.
    */
 var width = (box.rect[2] - box.rect[0]),
        height = (box.rect[3] - box.rect[1]);
    this.aspect = width / height;

    var columnCount = this.columns + this.column_lines.length * this.lineRatio,
        rowCount = this.rows + this.row_lines.length * this.lineRatio,
        columnSize = this.aspect / columnCount,
        rowSize = 1.0 / rowCount;

    this.cellSize = 2.0 * Math.min(columnSize, rowSize);
    this.lineWidth = this.cellSize * this.lineRatio;

    function offset(count, lines, offset) {
        var result = [],
            frontIndex = 0;

        for (var i = 0; i <= count; ++i) {
            var front = lines && lines[frontIndex];
            if (front !== undefined && front <= count) {
                offset += this.lineWidth;
                ++frontIndex;
            }
            result.push(offset);
            offset += this.cellSize;
        }
        return result;
    };

    this.column_offsets = offset(this.columns, this.column_lines, -this.aspect);
    this.row_offsets = offset(this.rows, this.row_lines, -1.0);

    this.reset();
};

Matrix.prototype.default_config = {
    rows: 16,
    columns: 16,
    color: {
        background: [1.0, 1.0, 1.0, 0.5],
        disabled: [0.9, 0.9, 0.9, 0.75],
        enabled: [0.0, 0.0, 0.0, 1.0],
        clicked_for_enable: [1.0, 0.7, 0.7, 1.0],
        clicked_for_disable: [0.5, 0.5, 0.5, 1.0],
        will_be_disabled: [0.5, 0.5, 0.5],
        selection: [1.0, 0.0, 0.0, 1.0],
        line_color: [0.5, 0.5, 0.5, 1.0],
    },
    circle_radius: 0.95,
    defer: true,
    merge_rows: [],

    column_names: ['a', 'b', 'c', 'd', 'e'],
    row_names: ['1', '2', '3', '4', '5'],

    //column_lines: [0, 1, 2],
    //row_lines: [3, 4],

    column_lines: [],
    row_lines: [],

    lineRatio: 0.01,
};

if (jsarguments.length > 1) {
    var config = Matrix.prototype.default_config;
    config.rows = Number(jsarguments[1]);
    config.columns = Number(jsarguments[2] || 0) || config.rows;
    config.column_names = config.row_names = undefined;
}

Matrix.DISABLED = 0;
Matrix.ENABLED = 1;
Matrix.CLICKED_FOR_ENABLE = 2;
Matrix.CLICKED_FOR_DISABLE = 3;
Matrix.WILL_BE_DISABLED = 4;

Matrix.CLICK_TRANSITION = [
    Matrix.CLICKED_FOR_ENABLE,
    Matrix.CLICKED_FOR_DISABLE,
    Matrix.DISABLED,
    Matrix.ENABLED,
    Matrix.ENABLED,
];

Matrix.CLEAR_TRANSITION = [
    Matrix.DISABLED,
    Matrix.ENABLED,
    Matrix.DISABLED,
    Matrix.ENABLED,
    Matrix.ENABLED
];

Matrix.RELEASE_TRANSITION = [
    Matrix.DISABLED,
    Matrix.ENABLED,
    Matrix.ENABLED,
    Matrix.DISABLED,
    Matrix.DISABLED
];

Matrix.prototype.reset = function() {
    this.forEach(Matrix.DISABLED);
};

Matrix.prototype.clear = function() {
    this.forEach(Matrix.CLEAR_TRANSITION);
};

Matrix.prototype.setColor = function(color) {
    sketch.glcolor(color[0], color[1], color[2], color[3]);
};

Matrix.prototype.setState = function(column, row, state) {
    var previousState = this.matrix[column][row]
    if (state !== undefined && previousState !== state) {
        this.matrix[column][row] = state;
        Max.Out.router(column, row, state);
    }
};

Matrix.prototype.forEach = function(func, dontDraw) {
    if (func instanceof Function) {
     for (var c = 0; c < this.columns; c++)
      for (var r = 0; r < this.rows; r++)
                this.setState(c, r, func(c, r, this.matrix[c][r]));
    } else if (func instanceof Array || func instanceof Object) {
     for (var c = 0; c < this.columns; c++)
      for (var r = 0; r < this.rows; r++)
                this.setState(c, r, func[this.matrix[c][r]]);
    } else {
     for (var c = 0; c < this.columns; c++)
      for (var r = 0; r < this.rows; r++)
                this.setState(c, r, func);
    }

    if (!dontDraw)
        this.draw()
};

Matrix.prototype.moveto = function(x, y) {
    sketch.moveto(x - 1.0, 1.0 - y, 0.0);
};

Matrix.prototype.clearScreen = function() {
    var back = this.color.background;
 sketch.glclearcolor(back[0], back[1], back[2], back[3]);
 sketch.glclear();
};

Matrix.prototype.draw = function() {
    this.clearScreen();
    // Draw the guidelines.
    this.setColor(this.color.line_color);

 with (sketch)
 {
        for (var i = 0; i < this.column_lines.length; ++i) {
            this.moveto(this.column_offsets[this.column_lines[i]], 0);
            sketch.line(0, -2, 0);
        }

        for (var i = 0; i < this.row_lines.length; ++i) {
            this.moveto(0, this.row_offsets[this.row_lines[i]]);
            sketch.line(2 * this.aspect, 0, 0);
        }

        var self = this;
        function drawCircle(c, r, state) {
         self.moveto(self.column_offsets[c] + self.cellSize / 2,
                        self.row_offsets[r] + self.cellSize / 2);
            self.setColor(self.colors[state]);
   circle(self.circle_radius * self.cellSize);
            return state;
  };
        this.forEach(drawCircle, true);

        // Draw the selection.
        if (this.selection) {
         this.moveto(this.column_offsets[this.selection[0]],
                        this.row_offsets[this.selection[1]]);
            this.setColor(this.color.selection);
            sketch.line(this.cellSize, 0, 0.0);
            sketch.line(0, -this.cellSize, 0.0);
            sketch.line(-this.cellSize, 0, 0.0);
            sketch.line(0, this.cellSize, 0.0);
        }
 }
    refresh();
};

Matrix.prototype.outputSelection = function() {
    var selection = ['', ''];
    if (this.selection) {
        var c = this.selection[0], r = this.selection[1];
        selection = [
            (this.column_names && this.column_names[c]) || c.toString(),
            (this.row_names && this.row_names[r]) || r.toString()];
    }
    Max.Out.selection(selection[0], selection[1]);
};

Matrix.prototype.onclick = function(x, y) {
 var world = sketch.screentoworld(x, y);
    post('click', world[0], world[1], '\n');
    if (!true) return;

 var column = Math.floor((world[0] + this.aspect) / this.cellSize);
 var row = Math.floor((1.0 - world[1]) / this.cellSize);
    post('.    ', column, row, '\n');
    this.clickSquare(column, row);
};

Matrix.prototype.clickSquare = function(column, row) {
    // post(column, row, '\n');
    var state = this.matrix[column][row];
    var mustDisable = (this.merge_rows.indexOf(row) == -1);
    var that = this;

    function change(before, after, output) {
        if (mustDisable)
            for (var c = 0; c < that.columns; ++c)
                if (c != column && that.matrix[c][row] == before)
                    that.setState(c, row, after);
    };

    this.selection = [column, row];
    this.outputSelection();

    if (this.defer) {
        if (state == Matrix.DISABLED) {
            change(Matrix.ENABLED, Matrix.WILL_BE_DISABLED);
            change(Matrix.CLICKED_FOR_ENABLE, Matrix.DISABLED);
        } else if (state == Matrix.CLICKED_FOR_ENABLE) {
            change(Matrix.WILL_BE_DISABLED, Matrix.ENABLED);
        } else if (state == Matrix.WILL_BE_DISABLED) {
            change(Matrix.CLICKED_FOR_ENABLE, Matrix.DISABLE);
        }
        this.setState(column, row, Matrix.CLICK_TRANSITION[state]);
    } else {
        this.setState(column, row, 1 - state);
        if (state == Matrix.DISABLED)
            change(Matrix.ENABLED, Matrix.DISABLED, true);
    }
 this.draw();
};

Matrix.prototype.setDefer = function(def) {
    if (this.defer && !def) {
        this.clear();
        this.draw();
    }
    this.defer = def;
};

Matrix.prototype.release = function() {
    if (!this.defer) {
        post('ERROR: not in defer mode\n');
        return;
    }
    this.forEach(Matrix.RELEASE_TRANSITION);
};

Matrix.prototype.move = function(dx, dy) {
    if (!this.selection) {
        if (dx > 0 || dy > 0)
            this.selection = [0, 0];
        else if (dx < 0)
            this.selection = [this.columns - 1, 0];
        else
            this.selection = [0, this.rows - 1];
    } else {
        this.selection[0] += dx;
        this.selection[1] += dy;
        if (this.selection[0] < 0)
            this.selection[0] += this.columns;
        if (this.selection[1] < 0)
            this.selection[1] += this.rows;

        if (this.selection[0] >= this.columns)
            this.selection[0] -= this.columns;
        if (this.selection[1] >= this.rows)
            this.selection[1] -= this.rows;
    }
    this.outputSelection();
    this.draw();
};

Matrix.prototype.toggle = function() {
    if (this.selection)
        this.clickSquare(this.selection[0], this.selection[1]);
};

var matrix = new Matrix();

sketch.default2d();
matrix.draw();

function onresize(w, h)
{
 matrix.draw();
};

function onclick(x, y)
{
    matrix.onclick(x, y);
};

function ondblclick(x, y)
{
 onclick(x, y);
};

// Make functions private to prevent triggering from Max.
onclick.local = 1;
ondblclick.local = 1;
onresize.local = 1;

function defer(def) {
    matrix.setDefer(!!def);
};

function release() {
    matrix.release();
};

function left() {
    matrix.move(-1, 0);
};

function right() {
    matrix.move(1, 0);
};

function up() {
    matrix.move(0, -1);
};

function down() {
    matrix.move(0, 1);
};

function toggle() {
    matrix.toggle();
};

function clear() {
    matrix.clear();
};

function reset() {
    matrix.reset();
};

function clear_selection() {
    matrix.selection = undefined;
    matrix.outputSelection();
    matrix.draw();
};

print('\nOriginal source:', "js/max/crossmatrix.js", ' Compile date:', 'Sun Jan  3 15:44:28 EST 2016');
