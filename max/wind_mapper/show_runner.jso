autowatch = 1;
outlets = 1;








var Max = new Object();
Max.patcher = this.patcher;

Max.inlets = {};
Max.scalarMessages = {msg_int: 1, msg_float: 1};
Max.applyEntry = true;

// Name each inlet and set a callback function
// Usage:
//   Max.SetInlets(['inletName', callbackFn, 'help'],
//                 ['nextInletName', callbackFn2, 'more help']);
// If there is no help entry, it defaults to the name of the inlet.
Max.SetInlets = function(_) {
    inlets = arguments.length;
    for (var i = 0; i < arguments.length; ++i) {
        var entry = arguments[i];
        Max.inlets[i] = {name: entry[0], func: entry[1]};
        var help = entry[2] ? (entry[0] + ': ' + entry[2]) : entry[0];
        setinletassist(i, help);
    }
    Max.setterInlets = false;
};

Max.ObjectInlets = function(object, names) {
    var results = [];

    var methods = object._methods;
    if (methods) {
        for (var i in methods) {
            var method = methods[i],
                name = method[0],
                help = method[1] || name,
                func = method[2] || object[name];
            if (!func)
                post('ERROR! no function for', name, '\n');
            results.push([name, func, help]);
        }
    } else {
        names = names || object.names;
        for (var i = 0; i < names.length; ++i)
            results.push([names[i], object[names[i]], names[i]]);
    }
    Max.SetInlets.apply(this, results);
};

Max.SetterInlets = function(item) {
    Max.setterItem = item;
    var names = item.names;
    inlets = names.length;
    for (var i = 0; i < names.length; ++i)
        setinletassist(i, names[i]);
}

// Return the name of the current inlet, or the numeric name if you haven't set
// the names.
Max.Inlet = function() {
    return (inlet in Max.inlets) ? Max.inlets[inlet] : inlet;
};

function anything(_) {
    var item = Max.setterItem;
    if (item) {
        var name = item.names[inlet];
        if (arguments.length == 0)
            item[name] = messagename;
        else if (arguments.length == 1 && Max.scalarMessages[messagename])
            item[name] = arguments[0];
        else
            item[name] = arrayfromargs(arguments);

        item.lastUpdated = name;
        item.update();
    } else {
        var entry = Max.inlets[inlet];
        if (entry && entry.func) {
            var args = arrayfromargs(arguments);
            if (!(messagename == 'list' || Max.scalarMessages[messagename]))
                args = [messagename].concat(args);
            if (Max.applyEntry)
                entry.func.apply(this, args);
            else
                entry.func(args);
        } else {
            if (entry)
                post('ENTRY! ');
            post('ERROR: anything didn\'t understand input for', inlet,
                 Max.Inlet(), '\n');
        }
    }
};







// Also see:
// http://www.optimalworks.net/blog/2007/web-development/javascript/array-detection
Array.Is = function(array) {
  return (array !== null) &&
    (typeof(array) == 'object') &&
    ((array.prototype === Array.prototype) ||
     (array.constructor &&
      !array.nodeType &&
      !array.item &&
      array.length !== undefined));
};

var MAX_DEPTH = 10;

function Print(item, depth) {
  depth = depth || 0;
  if (depth > MAX_DEPTH)
    return 'MAX_DEPTH';

  if (item == null)
    return 'null';

  if (item == 'undefined')
    return 'undefined';

  var t = typeof(item);
  if (t == 'string')
    return '"' + item + '"';

  if (t == 'function')
    return (item.name || 'unknown') + '()';

  if (t != 'object')
    return item + '';

  var is_array = Array.Is(item);
  var result = [is_array ? '[' : '{'];

  for (var index in item) {
    if (result.length > 1)
      result[result.length - 1] += ', ';
    var value = Print(item[index], depth + 1);
    result.push(is_array ? value : '"' + index + '": ' + value);
  }
  result.push(is_array ? ']' : '}');
  return result.join('');
};

function PrintJoin(_) {
  var res = [];
  for (var i = 0; i < arguments.length; ++i)
    res.push(Print(arguments[i]));
  return res.join(' ');
};

// This is a VERY useful function - it converts Javascript objects into a
// human-readable form, prints them on one line and then adds a trailing \n.
function Postln(_) {
  for (var i = 0; i < arguments.length; ++i)
    post(Print(arguments[i]));

  post('\n');
};

var Logging = {};

Logging.setLogging = function(on) {
  Logging.Log = on ? Postln : function() {};
};

Logging.setLogging(false);




var Laser = {
    channels: {
        mode: 0,
        pattern: 1,
        zoom: 2,
        xrot: 3,
        yrot: 4,
        zrot: 5,
        hpos: 6,
        vpos: 7,
        color: 8,
    }
};






var Util = {};

Util.Range = function (begin, end) {
    this.begin = (begin === undefined) ? 0 : begin;
    this.end = (end === undefined) ? 127 : end;
};

Util.Range.prototype.limit = function(x) {
    return Math.floor(Math.min(this.end, Math.max(this.begin, x)));
}

Util.Range.prototype.select = function(ratio) {
    var range = this.end - this.begin + 1;
    var w = range * ratio;
    var x = this.begin + w;
    return this.limit(x);
}

Util.Range.prototype.ratio = function(entry) {
    entry = this.limit(entry);
    return (entry - this.begin) / (this.end - this.begin);
};

var MovingHeadBase = 64,
    MovingHead = {
        channels: {
            x: 1 + MovingHeadBase,
            y: 2 + MovingHeadBase,
            rotation: 3 + MovingHeadBase,
            red: 4 + MovingHeadBase,
            green: 5 + MovingHeadBase,
            blue: 6 + MovingHeadBase,
            white: 7 + MovingHeadBase,
            partition: 8 + MovingHeadBase,
            inside: 9 + MovingHeadBase,
            dimmer: 10 + MovingHeadBase,
            strobe: 11 + MovingHeadBase,
            effect: 12 + MovingHeadBase,
            blank: 13 + MovingHeadBase,
            auto: 14 + MovingHeadBase,
        },
    },
    Ranges = {
        note: new Util.Range(33, 103),
        dmx: new Util.Range(0, 255),
        midi: new Util.Range(0, 127),

    };
/*
What does an envelope look like?  It takes an object:

data: [
  [time1, value],
  [time2, value, envelope, arguments],
]
length: time
loops: number
is_float: bool

times are strictly increasing!

*/

function Envelope(args) {
    this.data = args.data;
    this.length = args.length;

    var last = this.data.length - 1;
    if (this.length === undefined)
        this.length = this.data.length ? this.data[last][0] : 0;
    this.loops = args.loops;
    if (this.loops === undefined)
        this.loops = 1;
    this.is_float = args.is_float;

    var firstTime = this.data[0][0],
        lastTime = this.data[last][0],
        lastValue = this.data[last][1];

    this.time = 0;
    this.is_running = true;
    var self = this;

    this.run = function(time) {
        /** These is one more segment than there are times - because there is a
            segment before, a segment after, and then one between each time. */
        var loop_number = Math.floor(time / self.length);
        if (self.loops <= loop_number)
            return lastValue;
        time = time % self.length;

        if (time < firstTime)
            return undefined;
        if (time >= lastTime)
            return lastValue;

        for (var i = 1; i < last && time >= self.data[i][0]; ++i);
        var segBefore = self.data[i - 1],
            segAfter = self.data[i],
            segmentTime = segAfter[0] - segBefore[0],
            segmentHeight = segAfter[1] - segBefore[1],
            elapsedRatio = (time - segBefore[0]) / segmentTime,
            value = segBefore[1] + elapsedRatio * segmentHeight;
        return self.is_float ? value : Math.round(value);
        // TODO: fix rounding which is no doubt wrong.
    };
};




function BarSync(func) {
    return function(show) {
        var cueBar = show._time[0];
        var scratch = {};
        function run(time) {
            func(show, time + show._time[0] - cueBar, scratch);
        };
        return {'phasor': run};
    };
};

/**

A list of [controller, envelope].
Controller can be one number or it can be a list of numbers.

*/

function EnvelopeSequence(envelopes) {
    return BarSync(function(show, time) {
        for (var i in envelopes) {
            var e = envelopes[i];
            var value = e[1].run(time);
            if (value !== undefined) {
                var controllers = e[0], type = typeof(controllers);
                if (type === 'string')
                    controllers = [parseInt(controllers)];
                else if (type === 'number')
                    controllers = [controllers];

                for (var c in controllers)
                    show._dmxoutput(controllers[c], value);
            }
        }
    });
};







/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  v       The value
 * @return  Array           The RGB representation
 */
Util.hsvToRgb = function(h, s, v) {
    var rgb = Util.hsvToRgbRaw(hsv);
    return [range.midi.select(rgb[0]),
            range.midi.select(rgb[1]),
            range.midi.select(rgb[2])];
};

Util.hsvToRgbRaw = function(h, s, v) {
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
        default: post("Error ", h, ":", i, "\n");
    }

    return [r, g, b];
};


function NoteAndBreathMapper(channels) {
    function Mapper(show) {
        this.note = function(note, velocity) {
            if (velocity) {
                var hue = Ranges.note.ratio(note);
                var rgb = Util.hsvToRgbRaw(hue, 1, 1);
                show._dmxratio(channels.red, rgb[0]);
                show._dmxratio(channels.green, rgb[1]);
                show._dmxratio(channels.blue, rgb[2]);
            }
        };

        this.breath = function(bc) {
            var rat = Ranges.note.ratio(bc);
            show._dmxratio(channels.dimmer, Ranges.midi.ratio(bc));
        };
    };

    return function(show) { return new Mapper(show); };
};




/**

A list of [time, controller dictionary].
Controller can be one number or it can be a list of numbers.

*/

function Sequence(sequence) {
    return BarSync(function(show, time, scratch) {
        post(time, '\n');
        scratch.index = scratch.index || 0;
        for (; scratch.index < sequence.length; ++scratch.index) {
            var s = sequence[scratch.index];
            if (s[0] > time) {
                post('leaving', s[0], '\n');
                return;
            }
            var lights = s[1];
            if (lights) {
                for (var i in lights)
                    show._dmxoutput(parseInt(i), lights[i]);
            } else {
                show._clear();
            }
        };
    });
};







Max.foreach = function(f) {
    for (var i = Max.patcher.firstobject; i; i = i.nextobject)
        f(i);
};

Max.findObjects = function(name, value) {
    var result = [];
    Max.foreach(function(i) { if (i[name] == value) result.push(i); });
    return result;
};

Max.findName = function(name) {
  return Max.findObjects('varname', name);
};

Max.findSubpatcher = function(name) {
  return Max.findName(name, container)[0].subpatcher();
};

Max.findClass = function(name) {
    return Max.findObjects('maxclass', name);
};

Max.findAllObjects = function(name, unique) {
    var result = {};
    Max.foreach(function(max_object) {
        var value = max_object[name];
        if (value !== undefined && value != '') {
            if (value in result) {
                var instances = result[value];
                if (unique) {
                    post('ERROR: duplicate value for :' + name + ':' + value + ':', '\n');
                    post('instances!!!  ', Print(instances, 3), '\n'); }
                else
                    instances.push(max_object);
            } else {
                result[value] = unique ? max_object : [max_object];
            }
        }
    });
    return result;
};

Max.findFirstObject = function(name) {
    var result = {};
    Max.foreach(function(max_object) {
        var value = max_object[name];
        if (value !== undefined && value != '')
            result[value] = max_object;
    });
    return result;
};

Max.findAll = function() {
    return {
        'maxclass': Max.findFirstObject('maxclass'),
        'varname': Max.findFirstObject('varname'),
    };
};









Util.IsString = function(x) {
  return typeof(x) == 'string';
};

Util.ArrayToString = function(s) {
  return Util.IsString(s) ? s : s[0];
};

Util.RemoveQuotes = function(s) {
  var begin = 0, end = s.length;
  if (end && s[begin] == '"')
    ++begin;
  if (end > begin && s[end - 1] == '"')
    --end;
  return s.substring(begin, end);
};

Util.LiveStringToString = function(s) {
  return Util.RemoveQuotes(Util.ArrayToString(s));
};






Util.trimFrontRE = /^\s+/;
Util.trimBackRE = /\s+$/;

Util.trim = function(s) {
  if (typeof(s) != 'string') {
    post('Error at', "js/swirly/util/trim.js", ':', 12, ':', 'Not a string', ' ', Print(s), '\n');
    return s;
  }
  return s.replace(Util.trimBackRE, '').replace(Util.trimFrontRE, '');
};

// Read characters or JSON data from files.
var FileReader = new Object();

FileReader.LINE_SPLIT = /\r?\n/;
FileReader.PATH = [];

FileReader.SetPath = function(path) {
    FileReader.PATH = path;
    post('Current path is now', path.join(':'), '\n');
};

FileReader.separator = '/';

FileReader.IsRelative = function(name) {
    return (name[0] != this.separator) && (name.indexOf(':' ) == -1);
};

FileReader.Open = function(name) {
    name = Util.trim(name);
    var path = [''];
    if (FileReader.IsRelative(name))
        path = FileReader.PATH;

    for (var i in path) {
        var p = path[i];
        var file = new File(p.length ? (p + this.separator + name) : name);
        if (file.isopen)
            return file;
    }

    post('Error at', "js/swirly/util/FileReader.js", ':', 38, ':', "Couldn't open file", ' ', Print(name), '\n');
    return null;
};

FileReader.Read = function(filename, length) {
    var file = FileReader.Open(filename);
    return file && file.readstring(length || 1000000);
};

FileReader.CleanJsonComments = function(data) {
    var lines = data.split(FileReader.LINE_SPLIT);
    for (var i in lines) {
        var line = lines[i];
        var wasBackslash = false;
        for (var j = 0, len = line.length; j < len; j++) {
            if (wasBackslash) {
                wasBackslash = false;
            } else {
                var ch = line[j];
                if (ch == '\\') {
                    wasBackslash = true;
                } else if (ch == '#') {
                    lines[i] = line.substr(0, j);
                    break;
                }
            }
        }
    }
    return lines.join('\n');
};

FileReader.ParseJson = function(data, filename) {
    filename = filename || '(none)';
    try {
        data = FileReader.CleanJsonComments(data)
        return (data == '') ? {} : JSON.parse(data);
    } catch (err) {
        post('JSON error in file ' + filename + ':' +
             err.lineNumber + ': ' + err.name + '\n');
        return null;
    }
};

FileReader.ReadJson = function(filename, length) {
    var data = FileReader.Read(filename, length);
    return data && FileReader.ParseJson(data, filename);
};


function ShowRunner() {
    var self = this;

    this._methods = [
        // These methods can be overridden on the "mapper" object.
        ['note', 'MIDI note on and off'],
        ['breath', 'breath control'],
        ['program', 'program change'],
        ['pitchbend', 'pitchbend'],

        // ['level', 'audio level'], // This is disabled.

        // These methods can be overriden on the "sequence" object.
        ['phasor', 'The phasor value between 0 and 1'],
        ['transport', 'A list representing the transport number.'],
        ['timer', 'Result of some incoming time'],

        // These ones are hard-coded.
        ['sequence', 'Cues for the sequencer.'],
        ['mapper', 'Cues for the mapper.'],
        ['dmxusbpro', 'Menu output from the dmx USB pro'],

        // Debugging only.
        // ['envelope', 'test for envelope'],
    ];

    var objects = Max.findAll(),
        dmxusbpro = objects.maxclass.dmxusbpro,
        head = objects.
        dmxCache = [],
        cuesToRun = [],
        mapper = {},
        sequence = {},
        scene = {'mapper': {}, 'sequence' : {}},
        cues = {'mapper': [], 'sequence': []},
        multisliders = [
            objects.varname.laser_1,
            objects.varname.laser_2,
            objects.varname.laser_3,
            objects.varname.laser_4,
            objects.varname.moving_head],
        bankSizes = [9, 9, 9, 9, 14],
        bankSize = 16,
        bankCount = 5,
        channelCount = bankCount * bankSize;

    function canRun() {
        return self._time && self._time[1] == 1;
    }

    function runCues() {
        if (cuesToRun.length && canRun()) {
            cuesToRun.forEach(function(c) { c(); } );
            cuesToRun = [];
        }
    };

    function setDmx(channel, bank, entry, value) {
        dmxCache[channel] = value;
        dmxusbpro.message(channel, value);
        multisliders[bank].message('set', [entry + 1, value]);
        // objects.maxclass.number.message('set', value);
    };

    this._clear = function() {
        dmxCache = new Array(channelCount + 1); // We never use channel 0.

        for (var bank = 0; bank < bankCount; ++bank) {
            var base = bank * bankSize + 1;
            for (var entry = 0; entry < bankSizes[bank]; ++entry)
                setDmx(base + entry, bank, entry, 0);
        }
    };

    this._clear();

    this._dmxratio = function(channel, value) {
        self._dmxoutput(channel, Ranges.dmx.select(value));
    };

    this._dmxoutput = function(channel, value) {
        // Avoid sending the same value twice.
        if (value === dmxCache[channel])
            return;

        var bank = Math.floor(channel / bankSize),
            entry = channel - bankSize * bank;


        if (channel <= 0 || channel > channelCount) {
            post('ERROR: channel', channel, '\n');
            return;
        }

        if (value < 0 || value > 255) {
            post('ERROR: value', value, '\n');
            return;
        }

        var size = bankSizes[bank];
        if (entry > size) {
            post('ERROR: entry', entry, 'is greater than bank size', size,
                 'for bank', bank, channel, '\n');
            return;
        }


        setDmx(channel, bank, entry, value);
    };

    this.transport = function() {
        self._time = arrayfromargs(arguments);
        runCues();
        // scene.sequence.transport && scene.sequence.transport();
    };

    this.dmxusbpro = function(command, device) {
        if (command === 'append' && device != 'None')
            dmxusbpro.message(device);
    };

    function doCue(cueType, note) {
        var cue = cues[cueType][note];
        if (!cue) {
            post('ERROR: didn\'t understand cue', cueType, note, '\n');
            return;
        }
        function run() {
            var name = cue[0], sceneMaker = cue[1];
            post('Cue runs:', cueType + '.' + name, '\n');
            scene[cueType] = sceneMaker(self);
        }
        if (cueType === 'mapper' || canRun())
            run();
        else
            cuesToRun.push(run);
    };

    this.sequence = function(note) {
        doCue('sequence', note);
    };

    this.mapper = function(note) {
        doCue('mapper', note);
    };

    function delegate(cueType, method) {
        self[method] = function(_) {
            var fn = scene[cueType][method];
            if (fn)
                fn.apply(self, arguments);
        };
    }

    delegate('mapper', 'note');
    delegate('mapper', 'breath');
    delegate('mapper', 'program');
    delegate('mapper', 'pitchbend');

    delegate('sequence', 'phasor');
    delegate('sequence', 'timer');

    this.addCue = function(cueType, name, sceneMaker) {
        var cuesForType = cues[cueType]
        methodIndex = cuesForType.length.toString();
        name = name || methodIndex;
        cuesForType.push([name, sceneMaker]);
        post('New cue', cueType + '.' + name, '(' + methodIndex + ')\n');
    };
};

var _show_runner = new ShowRunner();

Max.ObjectInlets(_show_runner);

_show_runner.addCue(
    'sequence', 'test',
    EnvelopeSequence(
        [[MovingHead.channels.x, new Envelope(
            {
                data: [[0, 0], [4, 50], [8, 250]]
            })
         ]]
    )
);

_show_runner.addCue(
    'sequence', 'test2',
    Sequence(
        [[0, 0], [1, {2:100, 3:100}], [2, 0], [3, {2:100, 3:100}], [4, 0]]
    )
);

_show_runner.addCue(
    'mapper', 'test',
    NoteAndBreathMapper(MovingHead.channels)
);

post('Original source:', "js/max/show_runner.js", ' Compile date:', 'Thu May 21 23:59:34 EDT 2015', '\n');
