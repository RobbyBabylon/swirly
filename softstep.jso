


var Softstep = {};

Softstep.Enable = function(output) {
  var self = this;

  var sysex = {
    standalone: {
      off: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 11,
        43, 58, 0, 16, 4, 0, 0, 0, 0, 0, 0, 0, 0, 23, 31, 0, 0, 0, 0, 0, 247],

      on: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 11,
        43, 58, 0, 16, 4, 1, 0, 0, 0, 0, 0, 0, 0, 47, 126, 0, 0, 0, 0, 2, 247],
    },

    tether: {
      off: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 11,
        43, 58, 0, 16, 3, 0, 0, 0, 0, 0, 0, 0, 0, 80, 7, 0, 0, 0, 0, 0, 247],

      on: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 11,
        43, 58, 0, 16, 3, 1, 0, 0, 0, 0, 0, 0, 0, 104, 102, 0, 0, 0, 0, 0, 247],
    },

    el: {
      off: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 5,
        8, 37, 0, 32, 0, 0, 76, 28, 0, 0, 0, 12, 247],
      on: [
        240, 0, 27, 72, 122, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 5,
        8, 37, 1, 32, 0, 0, 123, 44, 0, 0, 0, 12, 247],
    }
  };

  function Enable(name, en) {
    var sys = sysex[name];
    if (!sys) {
      post('Sofstep.Enable: Cannot enable "' + name + '"\n');
      return;
    }

    var e = sys[en];
    if (!e) {
      post('Softstep.Enable: enabled should be on or off, not "' + en + '"\n');
      return;
    }
    output.apply(this, e);
  };

  self.El = function(e) { Enable('el', e); }
  self.Standalone = function(e) { Enable('standalone', e); }
  self.Tether = function(e) { Enable('tether', e); }
};
Softstep.sensorsPerPad = 4;
Softstep.firstSensor = 40;
Softstep.lastSensor = 86;
Softstep.keyList = [6, 1, 7, 2, 8, 3, 9, 4, 10, 5, 'Nav'];
Softstep.CCToKeySensor = function(cc, value) {
  post(cc, value, '\n');
  if (cc < Softstep.firstSensor || cc > Softstep.lastSensor || cc in [84, 85]) {
    post('ERROR: Bad softstep cc', cc, '\n');
    return ['bad', cc, 0];
  }
  if (cc == Softstep.lastSensor)
    return ['Pedal', 0, value];
  var index = Math.floor((cc - Softstep.firstSensor) / Softstep.sensorsPerPad);
  var key = "" + Softstep.keyList[index];
  var sensor = cc % 4;
  return [key, sensor, value];
};
Softstep.LED = function(output) {
  var self = this;
  self.colors = {green: 0, red: 1, yellow: 2};
  self.states = {off: 0, on: 1, blink: 2, fast: 3, flash: 4};
  function rawOutput(led, color, state) {
    output(176, 40, led == 'all' ? 127 : led);
    output(176, 41, self.colors[color]);
    output(176, 42, self.states[state]);
    output(176, 0, 0);
    output(176, 0, 0);
    output(176, 0, 0);
  };
  function check(color, state) {
    if (self.colors[color] === null)
      post("Don't understand color '" + color + "'\n");
    else if (self.states[state] == null)
      post("Don't understand state '" + state + "'\n");
    else
      return true;
    return false;
  };
  // Set a given state and guarantee that the other states are off.
  self.Led = function(led, color, state) {
    if (check(color, state)) {
      if (color == 'red')
        rawOutput(led, 'green', 'off');
      else if (color == 'green')
        rawOutput(led, 'red', 'off');
      rawOutput(led, color, state);
    }
  };
};
// A "general" scroller that works for any sort of device where you can scroll a
// portion a string in a fixed character width display.
//
// output is a callback function that computes the scrolling string and sends
// it to Max (probably sending it to an outlet).
//
// config is a dictionary that can have the following properties:
//
//   callback:  this function is called when the last loop executes.
//
//   delta:     how to scroll - +1 is forward, -1 backward
//
//   message:   the message to scroll (default '').
//
//   period:    the delay between scroll increments, in ms (default 200).
Softstep.Scroller = function(output, config) {
  var self = this;
  self.config = config || {};
  self.queue = [];
  self.running = false;
  self.displayLength = self.config.displayLength ||
    Softstep.Scroller.defaultDisplayLength;
  // Display the current state of the scroller.
  function Display() {
    var m = self.config.message || '';
    var len = self.displayLength;
    while (m.length < len) // Only good if len is not large.
      m += ' ';
    m += ' ';
    output((m + m).substring(self.offset, self.offset + len));
  };
  // Pull off the next queue item, if any, and execute it.
  function NextQueue() {
    if (self.queue.length) {
      var command = self.queue.shift();
      if (typeof(command) == 'string')
        command = [command];
      self.SetMessage(command[0]);
      self.config.loops = parseInt(command[1] || '0');
      if (command.length > 2)
        self.config.period = parseInt(command[2]);
      self.Start();
    };
  };
  // Schedule the task exactly once.
  function Schedule() {
    var period = Math.max(self.config.period || Softstep.Scroller.defaultPeriod,
                          Softstep.Scroller.minimumPeriod);
    self.task.schedule(period);
  };
  self._Run = function() {
    self.running = Increment();
    Display();
    if (self.running)
      Schedule();
    else
      NextQueue();
  };
  // Deal with annoying bug in Task...
  function Run() {
    this._Run();
  };
  self.task = new Task(Run, this);
  function Increment() {
    self.offset += (self.config.delta || 1);
    if (self.offset < 0)
      self.offset = Length() - 1;
    else if (self.offset > Length())
      self.offset = 0;
    else
      return true;
    if (++self.loops <= self.config.loops)
      return true;
    if (self.config.loops)
      return false;
    return !self.queue.length;
  };
  // Length of the scrollable message (right-padded to fit the display).
  function Length() {
    return Math.max(self.displayLength, self.config.message.length);
  };
  self.Start = function() {
    self.Stop();
    self.loops = self.offset = 0;
    Display();
    Schedule();
    self.running = true;
  };
  self.Stop = function() {
    self.offset = 0;
    self.Freeze();
  };
  self.Clear = function() {
    self.config.message = '';
    self.queue = [];
    self.Stop();
  };
  self.Freeze = function() {
    self.task.cancel();
    Display();
    self.running = false;
  };
  self.Display = function(m) {
    self.config.message = m;
    self.offset = 0;
    self.loops = 0;
    Display();
  };
  self.Period = function(p) {
    p = parseInt(p);
    self.config.period = p;
    if (self.task)
      self.task.interval = p;
  };
  self.Queue = function(_) {
    self.queue.push(arrayfromargs(arguments));
    if (!self.running)
      NextQueue();
  };
};
Softstep.Scroller.defaultDisplayLength = 4;
Softstep.Scroller.defaultPeriod = 200;
// I've taken Softstep.Scroller.minimumPeriod as low as 1 with no ill effects
// BUT the company warns you might brick your pedal.  BEWARE SETTING THIS TOO
// LOW.
Softstep.Scroller.minimumPeriod = 20;
// Also see:
// http://www.optimalworks.net/blog/2007/web-development/javascript/array-detection
Array.Is = function(array) {
  return (array !== null) &&
    (typeof(array) == 'object') &&
    ((array.prototype === Array.prototype) ||
     (array.constructor &&
      !array.nodeType &&
      !array.item &&
      array.length !== undefined));
};
var MAX_DEPTH = 10;
function Print(item, depth) {
  depth = depth || 0;
  if (depth > MAX_DEPTH)
    return 'MAX_DEPTH';
  if (item == null)
    return 'null';
  if (item == 'undefined')
    return 'undefined';
  var t = typeof(item);
  if (t == 'string')
    return '"' + item + '"';
  if (t == 'function')
    return (item.name || 'unknown') + '()';
  if (t != 'object')
    return item + '';
  var is_array = Array.Is(item);
  var result = [is_array ? '[' : '{'];
  for (var index in item) {
    if (result.length > 1)
      result[result.length - 1] += ', ';
    var value = Print(item[index], depth + 1);
    result.push(is_array ? value : '"' + index + '": ' + value);
  }
  result.push(is_array ? ']' : '}');
  return result.join('');
};
// This is a VERY useful function - it converts Javascript objects into a
// human-readable form, prints them on one line and then adds a trailing \n.
function Postln(_) {
  for (var i = 0; i < arguments.length; ++i)
    post(Print(arguments[i]));
  post('\n');
};
Softstep.Controller = function(output) {
  var self = this;
  function scrollerOutput(s) {
    s += '    ';
    for (var i = 0; i < 4; ++i)
      output.midiout(176, 50 + i, s.charCodeAt(i));
  };
  self.scroller = new Softstep.Scroller(scrollerOutput);
  self.led = new Softstep.LED(output.midiout);
  self.enable = new Softstep.Enable(output.midiout);
  self._commands = {};
  function addCommands(_) {
    var names = [];
    for (var i = 0; i < arguments.length; ++i) {
      var object = arguments[i];
      for (var name in object) {
        var member = object[name];
        if (typeof(member) == 'function' && name[0] != '_') {
          name = name.toLowerCase();
          names.push(name);
          self._commands[name] = member;
        }
      }
    }
    return names.sort().join(', ');
  };
  self.Init = function() {
    output.midiout('SSCOM Port 1');
    output.midiin('SSCOM Port 1');
    self.enable.Tether('off');
    self.enable.Standalone('on');
  };
  self.commands = addCommands(self.scroller, self.led, self.enable, self);
  self.Command = function(command) {
    var cmd = self._commands[command[0]];
    if (cmd)
      cmd.apply(this, command.slice(1));
    else
      post("Didn't understand command '" + command + '"\n');
  };
  self.MidiIn = function(cc) {
    post('midiin!', cc, '\n');
    output.command.apply(this, Softstep.CCToKeySensor(cc[1], cc[0]));
  };
};
var Max = new Object();
// Name each inlet and set a callback function
// Usage:
//   Max.SetInlets(['inletName', callbackFn, 'help'],
//                 ['nextInletName', callbackFn2, 'more help']);
// If there is no help entry, it defaults to the name of the inlet.
Max.SetInlets = function(_) {
  inlets = arguments.length;
  for (var i = 0; i < arguments.length; ++i) {
    var entry = arguments[i];
    Max.inlets[i] = {name: entry[0], func: entry[1]};
    setinletassist(i, entry[2] || entry[0]);
  }
};
// Return the name of the current inlet, or the numeric name if you haven't set
// the names.
Max.Inlet = function() {
  return (Max.inlets && inlet in Max.inlets) ? Max.inlets[inlet] : inlet;
};
function anything(_) {
  var entry = Max.inlets[inlet];
  if (entry && entry.func) {
    var args = arrayfromargs(arguments);
    if (messagename != 'msg_int' && messagename != 'msg_float')
      args = [messagename].concat(args);
    entry.func(args);
  } else {
    post("Didn't understand input for", Max.Inlet(), '\n');
  }
};
Max.inlets = {};
var Util = {};
Util.IsString = function(x) {
  return typeof(x) == 'string';
};
Util.ArrayToString = function(s) {
  return Util.IsString(s) ? s : s[0];
};
Util.RemoveQuotes = function(s) {
  var begin = 0, end = s.length;
  if (end && s[begin] == '"')
    ++begin;
  if (end > begin && s[end - 1] == '"')
    --end;
  return s.substring(begin, end);
};
// Max.SetOutlets sets the names and thus the number of outlets for your Max js
// box.
//
// A sample call looks like:
//
//    Max.SetOutlets('midi',
//                   ['synth', 'Messages to the synthesis subpatcher.'],
//                   ['finished', 'Outlets a bang when the song is finished.']);
//
// or more generally, like this:
//
//    Max.SetOutlets(out1, out2, ...);
//
// Each name argument can either be a string, or a list of two strings.  For
// each argument, the name of the corresponding outlet is the first string, and
// the help text is the second string, if there is one, or else the name of the
// outlet.
//
//    You should only call this function once, and you have to call it during
// the "top-level phase" when the Javascript is first being executed and before
// the box is actually created - if you try to call this later, nothing will
// fail, but you won't get the right number of outlets from the js box.
//
// Once you've called
// If you start with:
//
//   Max.SetOutlets('foo', 'bar', 'baz');
//
// then the following code blocks have identical meaning, and all send the
// message ['hello', 'world'] out the first outlet, named foo, and the message
// ['hello', 'there!'] and ['goodbye!' out the second Max outlet, named bar:
//
//   {
//     Max.Out('foo', 'hello', 'world');
//     Max.Out('bar', 'hello', 'there!');
//     Max.Out('bar', 'goodbye!');
//   }
//
//   {
//     Max.Out.foo('hello', 'world');
//     Max.Out.bar('hello', 'there!');
//     Max.Out.bar('goodbye!');
//   }
//
//   {
//     Max.ListOut(['foo', 'hello', 'world'],
//                 ['bar', 'hello', 'there!'],
//                 ['bar', 'goodbye!']);
//   }
//
//   {
//     Max.ListOut.foo(['hello', 'world']);
//     Max.ListOut.bar(['hello', 'there!'], ['goodbye!']);
//   }
//
//   {
//     var func = Max.Outer(['foo', 'hello', 'world'],
//                          ['bar', 'hello', 'there!'],
//                          ['bar', 'goodbye!']);
//     func();
//   }
//
//   {
//     var func1 = Max.Outer.foo(['hello', 'world']);
//     var func2 = Max.Outer.bar(['hello', 'there!'], ['goodbye!']);
//
//     func1();
//     func2();
//   }
//
Max._outlets = {};
// Outlet to a named outlet.  You can still use the numbered outlets, too.
// You can override this in tests if you want to capture the MIDI output.
//
Max.Outlet = function(outletNumber, data) {
  if (Max._outlets && outletNumber in Max._outlets)
    outletNumber = Max._outlets[outletNumber];
  outlet(outletNumber || 0, data);
};
Max.Out = function(out, _) {
  Max.Outlet(out, arrayfromargs(arguments).slice(1));
};
Max.ListOut = function(args) {
  for (var i = 0; i < args.length; ++i)
    Max.Outlet(args[i][0], args[i].slice(1));
};
Max.Outer = function(_) {
  var args = arguments;
  return function() {
    for (var i = 0; i < arguments.length; ++i)
      Max.Outlet(arguments[i][0], arguments[i].slice(1));
  };
};
Max.SetOutlets = function(_) {
  outlets = arguments.length;
  Max._outlets = {};
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i], help = name;
    if (!Util.IsString(name)) {
      help = name[1] || name;
      name = name[0];
    }
    Max._outlets[name] = i;
    setoutletassist(i, help);
    Max.Out[name] = Max.OutletFunction(i);
    Max.ListOut[name] = Max.OutletListFunction(i);
    Max.Outer[name] = Max.OutletFunctionMaker(i);
  }
};
//
// Implementation details below here!
//
// Returns a function that sends its arguments as a message to a given outlet.
Max.OutletFunction = function(out) {
  return function(_) {
    outlet(out, arrayfromargs(arguments));
  };
};
// Returns a function that sends its arguments as separate messages to a given
// outlet.
Max.OutletListFunction = function(out) {
  return function(_) {
    for (var i = 0; i < arguments.length; ++i)
      outlet(out, arguments[i]);
  };
};
// Returns a function that sends its arguments as separate messages to a given
// outlet.
Max.OutletFunctionMaker = function(out) {
  return function(messages) {
    return function() {
      for (var i = 0; i < messages.length; ++i)
        outlet(out, messages[i]);
    }
  };
};
autowatch = 1;
Max.SetOutlets(['midiout', 'Midi data to the softstep'],
               ['command', 'Commands from the softstep'],
               ['midiin', 'Commands to the midin or ctlin that receives softstep data']);
var _softstep = new Softstep.Controller(Max.Out);
Max.SetInlets(['midiin', _softstep.MidiIn,
               'Continuous controller data.'],
              ['command', _softstep.Command,
               'Commands to the softstep: ' + _softstep.commands]);
post('Compiled sofstep.js on ' + new Date().toString(), '\n');
post('Commands are:', _softstep.commands, '\n');
